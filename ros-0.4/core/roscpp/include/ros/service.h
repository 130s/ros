/*
 * Copyright (C) 2008, Morgan Quigley and Willow Garage, Inc.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the names of Stanford University or Willow Garage, Inc. nor the names of its
 *     contributors may be used to endorse or promote products derived from
 *     this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef ROSCPP_SERVICE_H
#define ROSCPP_SERVICE_H

#include <string>
#include "ros/common.h"
#include "ros/message.h"

#include <boost/shared_ptr.hpp>

namespace ros
{

class ServiceClient;
typedef boost::shared_ptr<ServiceClient> ServiceClientPtr;

namespace service
{

/** @brief Invoke an RPC service.
 *
 * This method invokes an RPC service on a remote server, looking up the
 * service location first via the master.
 *
 * @param service_name The name of the service.
 * @param req The request message.
 * @param[out] res Storage for the response message.
 *
 * @return true on success, false otherwise.
 */
template<class MReq, class MRes>
bool call(const std::string& service_name, MReq& req, MRes& res)
{
  if (req.__getServerMD5Sum() != res.__getServerMD5Sum())
  {
    ROS_FATAL("woah! the request and response parameters to the server "
                 "callback function must be autogenerated from the same "
                 "server definition file (.srv). your service call "
                 "for %s appeared to use request/response types "
                 "from different .srv files.", service_name.c_str());
    ROS_BREAK();
  }

  return callImpl(service_name, &req, &res, req.__getServerMD5Sum());
}

/**
 * \brief Wait for a service to be advertised and available.  Blocks until it is.
 * \param service_name Name of the service to wait for.
 * \param timeout The amount of time to wait for, in milliseconds.  If timeout is -1 (default),
 * waits until the node is shutdown
 * \return true on success, false otherwise
 */
bool waitForService(const std::string& service_name, int32_t timeout = -1);

/**
 * \brief Checks if a service is both advertised and available.
 * \param service_name Name of the service to check for
 * \param print_failure_reason Whether to print the reason for failure to the console (service not advertised vs.
 * could not connect to the advertised host)
 * \return true if the service is up and available, false otherwise
 */
bool exists(const std::string& service_name, bool print_failure_reason);

/**
 * @brief Provides an interface to a persistent service connection.
 */
class ServiceHandle
{
public:
  ServiceHandle(const std::string& service_name, bool persistent, const M_string& header_values, const std::string& service_md5sum);
  ~ServiceHandle();

  /**
   * @brief Call the service aliased by this handle with the specified request/response messages.
   * @note The request/response message types must match the types specified in the templated call to createHandle()
   */
  template<class MReq, class MRes>
  bool call(MReq& req, MRes& res)
  {
    if (req.__getServerMD5Sum() != res.__getServerMD5Sum())
    {
      ROS_FATAL("woah! the request and response parameters to the server "
                   "callback function must be autogenerated from the same "
                   "server definition file (.srv). your service call "
                   "for %s appeared to use request/response types "
                   "from different .srv files.", name_.c_str());
      ROS_BREAK();
    }

    return callImpl(&req, &res, req.__getServerMD5Sum());
  }

  /**
   * \brief For internal use
   */
  bool callImpl(Message* req, Message* resp, const std::string& service_md5sum);

  /**
   * \brief Returns whether or not this handle is valid.  For a persistent service, this becomes false when the connection has dropped.
   * Non-persistent service handles are always valid.
   */
  bool valid();

  const ServiceClientPtr& getClient() { return client_; }

private:
  ServiceClientPtr client_;
  std::string name_;
  bool persistent_;
  M_string header_values_;
  std::string service_md5sum_;
};
typedef boost::shared_ptr<ServiceHandle> ServiceHandlePtr;

typedef std::map<std::string, std::string> M_string;

/** @brief Create a handle to a service connection.
 *
 * When the last handle reference of a persistent connection is cleared, the connection will automatically close.
 *
 * @note The persistent option is not yet implemented.  All handles returned by this function are currently to persistent connections.
 *
 * @param service_name The name of the service to connect to
 * @param persistent Whether this connection should persist.  Persistent services keep the connection to the remote host active
 *        so that subsequent calls will happen faster.  In general persistent services are discouraged, as they are not as
 *        robust to node failure as non-persistent services.
 * @param header_values Key/value pairs you'd like to send along in the connection handshake
 */
template<class MReq, class MRes>
ServiceHandlePtr createHandle(const std::string& service_name, bool persistent = false, const M_string& header_values = M_string())
{
  return createHandleImpl(service_name, persistent, header_values, MReq::__s_getServerMD5Sum());
}

/**
 * @brief For internal use only, don't call this
 */
bool callImpl(const std::string& service_name, Message* req, Message* resp, const std::string& service_md5sum);
ServiceHandlePtr createHandleImpl(const std::string& service_name, bool persistent, const M_string& header_values, const std::string& service_md5sum);

}

}

#endif // ROSCPP_SERVICE_H

