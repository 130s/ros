/**
\mainpage
\htmlinclude manifest.html

\section Overview 

\b roslisp is a library for writing ROS nodes in ANSI Common Lisp.  See the installation guide for how to set up roslisp for standalone compilation of lisp source files and/or interactive use.  This page lists the functions available in the client library and other miscellaneous information.  Detailed documentation about the functions is available within the Lisp environment using the documentation feature.

\section build Integration with build system

Roslisp is integrated with asdf build system.  The function load-manifest uses rospack to add the appropriate directories for a package to the central registry.  To run nodes from the Lisp environment, ensure that the variable asdf:*central-registry* includes (a symbolic link to) roslisp/asdf and, at startup (e.g. in .sbclrc), do:
\verbatim
(asdf:operate 'asdf:load-op :ros-load-manifest)
(ros-load-manifest:load-manifest "roslisp")
\endverbatim

To load some roslisp package foo, ensure that foo/asdf/ contains a symbolic link to the asdf build files for that package.  If the asdf file is foo/asdf/foo-system.asd, then do:
\verbatim
(ros-load-manifest:load-manifest "foo")
(asdf:operate 'asdf:load-op :foo-system)
\endverbatim

You can also build standalone nodes in the CMakeLists.txt file.  For example, roslisp_examples/CMakeLists.txt contains
\verbatim
rospack_add_lisp_executable(bin/talker roslisp-examples roslisp-talker:main)
\endverbatim

This produces the executable roslisp_examples/bin/talker when built.  When run from the command line, the executable does not load your standard .sbclrc init file.  Rather, it loads ~/.sbclrc-roslisp (if it exists).  It then does the appropriate load-manifest calls to ensure that all dependees of roslisp-examples are in the asdf central registry.  It then loads the asdf system :roslisp-examples into memory.  Next, it loads the files bin/roslisp-init.lisp and bin/roslisp-talker:main.init.lisp (if they exist).  These are the places where you can put global, package-specific, and node-specific runtime customizations (customizing debug levels, setting optimization flags, modifying constants).  Finally, it calls the function roslisp-talker:main.


\section debug Debugging output

Roslisp provides a hierarchical, customizable-at-runtime, logging scheme, similar to rosconsole for roscpp.  Debug topics are lists, e.g. (roslisp top).  For such a topic, the debug level of (roslisp top) would be looked up.  If this is not present (roslisp) is looked up.  If this is not present, () is looked up (and this is always present in the topic list).  The level at runtime then determines whether the message is evaluated and outputted (to stdout and rosout).  To customize the logging behavior of a standalone node at runtime, edit the initialization file for that node (see build system description above).

To set debug levels, use set-debug-levels.  To produce debugging output, use ros-{debug|info|warn|error|fatal}.

Roslisp itself uses debugging levels starting with the symbol roslisp:roslisp, with subtopics roslisp:top and roslisp:tcp.  For example, if debugging roslisp_examples/bin/talker, add the following line to roslisp_examples/bin/roslisp-init.lisp:
\verbatim
(roslisp:set-debug-level 'roslisp:roslisp :debug)
\endverbatim

To reduce the number of connection-related debugging messages, also add the line
\verbatim
(roslisp:set-debug-level '(roslisp:roslisp roslisp:tcp) :info)
\endverbatim


\section Packages

The functions in the client API below belong to the Lisp package (namespace) named :roslisp, with the exception of the constructors and field accessors for ROS message data types, which belong to a Lisp package with the same name as the message's ROS package, and the ones for services, which belong to a Lisp package whose name is the concatenation of the ROS package name and "-srv".

\section Names

Names (of topics, services, and parameters) are handled according to standard ROS conventions.  Command-line arguments to the executable, of the form foo:=bar, where foo is not __name, __log, or __ns, are known as command line remappings.  Given such a remapping, any topic, parameter, or service referred to as foo in the node's code would then be replaced by bar.  The node name is given by the argument to start-ros-node or with-ros-node.  It can, however, be overridden by including a command-line argument of the form __name=foo.  The namespace is set as follows: if there is a command-line argument __ns:=foo, the namespace is foo.  If not, and if the environment variable ROS_NAMESPACE is set to bar, the namespace is bar.  If not, the namespace is /.  All commands below that take a name of a topic, service, or parameter can be given an absolute (/foo/bar/baz), relative (baz/qux), or private (~qux) name.

\section startstop Starting and stopping a node

See documentation for functions start-ros-node, shutdown-ros-node, and with-ros-node.

\section topic Topics

See functions advertise, subscribe, publish.

\section services Services

See functions call-service, def-service-callback, register-service.

\section params Parameters

See functions get-param, set-param, has-param, delete-param.

\section misc Miscellaneous functions

See make-uri, fully-qualified-name, loop-at-most-every, ros-time.

\section types Message data types

Each ROS message type has a corresponding Lisp class and operations on it.  A message type foo in ROS package bar corresponds to a Lisp class named <foo> in the bar Lisp package.  If your code will create or operate on objects of this type, it should contain the form (roslisp:load-message-types "bar/foo").  Operations in the message's package:

- An object of type <foo> in package bar, with initial value of field baz equal to 3, is created using (make-instance 'bar:<foo> :baz 3).  
- Given a field named baz in an object m of the above message type, it can be accessed (read or written to) using (bar:baz-val m).
      
The roslisp Lisp package contains some additional generic operations that work on any message:
- symbol-code M S.  M is either a message or the name of a message class.  S is a keyword symbol naming a constant declaration in the .msg file.  Returns the value of the constant.  For example, to get the value of the DEBUG constant in roslib/Log.msg, use (symbol-code 'roslib:<Log> :debug) or (symbol-code m :debug) where m is an instance of '<Log>.
- ros-message-to-list MSG
- list-to-ros-message L
- pprint-ros-message STREAM MSG prints the message to the given stream in human-readable format.  This is also set as the default dispatch function for ROS messages in Lisp's pretty printer.  So if you have pretty printing turned on, and call a function from the prompt that returns a ROS message, that return value will be printed human-readably using pprint-ros-message.  Similarly, if your code contains something like (format t "The message is ~a" m), that will DTRT.

There are a few additional operations that use the list representation of ros messages, and are therefore less efficient, but more readable and convenient for interactive use.  See with-fields and make-message.

\section services Service Data Types

Given a ROS service type qux in the bar ROS package, there are corresponding message types <qux-request> and <qux-response> in the bar-srv Lisp package. Code that uses these should contain a call to

\verbatim
(roslisp:load-service-types "bar/qux")
\endverbatim

The request and response messages can be operated on like any other message.
*/